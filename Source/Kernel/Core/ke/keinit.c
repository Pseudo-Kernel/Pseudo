
/**
 * @file keinit.c
 * @author Pseudo-Kernel (sandbox.isolated@gmail.com)
 * @brief Implements kernel initialization routines.
 * @version 0.1
 * @date 2021-09-26
 * 
 * @copyright Copyright (c) 2021
 * 
 * @todo Initialize GDT/IDT/TSS (per processor)
 */

#include <base/base.h>
#include <ke/lock.h>
#include <ke/keinit.h>
#include <ke/interrupt.h>
#include <mm/mm.h>
#include <mm/pool.h>
#include <init/bootgfx.h>

PTR KiInterruptHandlers[0x100] =
{
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&KiInterruptNop,
    (PTR)&INTERRUPT_HANDLER_NAME(32),
    (PTR)&INTERRUPT_HANDLER_NAME(33),
    (PTR)&INTERRUPT_HANDLER_NAME(34),
    (PTR)&INTERRUPT_HANDLER_NAME(35),
    (PTR)&INTERRUPT_HANDLER_NAME(36),
    (PTR)&INTERRUPT_HANDLER_NAME(37),
    (PTR)&INTERRUPT_HANDLER_NAME(38),
    (PTR)&INTERRUPT_HANDLER_NAME(39),
    (PTR)&INTERRUPT_HANDLER_NAME(40),
    (PTR)&INTERRUPT_HANDLER_NAME(41),
    (PTR)&INTERRUPT_HANDLER_NAME(42),
    (PTR)&INTERRUPT_HANDLER_NAME(43),
    (PTR)&INTERRUPT_HANDLER_NAME(44),
    (PTR)&INTERRUPT_HANDLER_NAME(45),
    (PTR)&INTERRUPT_HANDLER_NAME(46),
    (PTR)&INTERRUPT_HANDLER_NAME(47),
    (PTR)&INTERRUPT_HANDLER_NAME(48),
    (PTR)&INTERRUPT_HANDLER_NAME(49),
    (PTR)&INTERRUPT_HANDLER_NAME(50),
    (PTR)&INTERRUPT_HANDLER_NAME(51),
    (PTR)&INTERRUPT_HANDLER_NAME(52),
    (PTR)&INTERRUPT_HANDLER_NAME(53),
    (PTR)&INTERRUPT_HANDLER_NAME(54),
    (PTR)&INTERRUPT_HANDLER_NAME(55),
    (PTR)&INTERRUPT_HANDLER_NAME(56),
    (PTR)&INTERRUPT_HANDLER_NAME(57),
    (PTR)&INTERRUPT_HANDLER_NAME(58),
    (PTR)&INTERRUPT_HANDLER_NAME(59),
    (PTR)&INTERRUPT_HANDLER_NAME(60),
    (PTR)&INTERRUPT_HANDLER_NAME(61),
    (PTR)&INTERRUPT_HANDLER_NAME(62),
    (PTR)&INTERRUPT_HANDLER_NAME(63),
    (PTR)&INTERRUPT_HANDLER_NAME(64),
    (PTR)&INTERRUPT_HANDLER_NAME(65),
    (PTR)&INTERRUPT_HANDLER_NAME(66),
    (PTR)&INTERRUPT_HANDLER_NAME(67),
    (PTR)&INTERRUPT_HANDLER_NAME(68),
    (PTR)&INTERRUPT_HANDLER_NAME(69),
    (PTR)&INTERRUPT_HANDLER_NAME(70),
    (PTR)&INTERRUPT_HANDLER_NAME(71),
    (PTR)&INTERRUPT_HANDLER_NAME(72),
    (PTR)&INTERRUPT_HANDLER_NAME(73),
    (PTR)&INTERRUPT_HANDLER_NAME(74),
    (PTR)&INTERRUPT_HANDLER_NAME(75),
    (PTR)&INTERRUPT_HANDLER_NAME(76),
    (PTR)&INTERRUPT_HANDLER_NAME(77),
    (PTR)&INTERRUPT_HANDLER_NAME(78),
    (PTR)&INTERRUPT_HANDLER_NAME(79),
    (PTR)&INTERRUPT_HANDLER_NAME(80),
    (PTR)&INTERRUPT_HANDLER_NAME(81),
    (PTR)&INTERRUPT_HANDLER_NAME(82),
    (PTR)&INTERRUPT_HANDLER_NAME(83),
    (PTR)&INTERRUPT_HANDLER_NAME(84),
    (PTR)&INTERRUPT_HANDLER_NAME(85),
    (PTR)&INTERRUPT_HANDLER_NAME(86),
    (PTR)&INTERRUPT_HANDLER_NAME(87),
    (PTR)&INTERRUPT_HANDLER_NAME(88),
    (PTR)&INTERRUPT_HANDLER_NAME(89),
    (PTR)&INTERRUPT_HANDLER_NAME(90),
    (PTR)&INTERRUPT_HANDLER_NAME(91),
    (PTR)&INTERRUPT_HANDLER_NAME(92),
    (PTR)&INTERRUPT_HANDLER_NAME(93),
    (PTR)&INTERRUPT_HANDLER_NAME(94),
    (PTR)&INTERRUPT_HANDLER_NAME(95),
    (PTR)&INTERRUPT_HANDLER_NAME(96),
    (PTR)&INTERRUPT_HANDLER_NAME(97),
    (PTR)&INTERRUPT_HANDLER_NAME(98),
    (PTR)&INTERRUPT_HANDLER_NAME(99),
    (PTR)&INTERRUPT_HANDLER_NAME(100),
    (PTR)&INTERRUPT_HANDLER_NAME(101),
    (PTR)&INTERRUPT_HANDLER_NAME(102),
    (PTR)&INTERRUPT_HANDLER_NAME(103),
    (PTR)&INTERRUPT_HANDLER_NAME(104),
    (PTR)&INTERRUPT_HANDLER_NAME(105),
    (PTR)&INTERRUPT_HANDLER_NAME(106),
    (PTR)&INTERRUPT_HANDLER_NAME(107),
    (PTR)&INTERRUPT_HANDLER_NAME(108),
    (PTR)&INTERRUPT_HANDLER_NAME(109),
    (PTR)&INTERRUPT_HANDLER_NAME(110),
    (PTR)&INTERRUPT_HANDLER_NAME(111),
    (PTR)&INTERRUPT_HANDLER_NAME(112),
    (PTR)&INTERRUPT_HANDLER_NAME(113),
    (PTR)&INTERRUPT_HANDLER_NAME(114),
    (PTR)&INTERRUPT_HANDLER_NAME(115),
    (PTR)&INTERRUPT_HANDLER_NAME(116),
    (PTR)&INTERRUPT_HANDLER_NAME(117),
    (PTR)&INTERRUPT_HANDLER_NAME(118),
    (PTR)&INTERRUPT_HANDLER_NAME(119),
    (PTR)&INTERRUPT_HANDLER_NAME(120),
    (PTR)&INTERRUPT_HANDLER_NAME(121),
    (PTR)&INTERRUPT_HANDLER_NAME(122),
    (PTR)&INTERRUPT_HANDLER_NAME(123),
    (PTR)&INTERRUPT_HANDLER_NAME(124),
    (PTR)&INTERRUPT_HANDLER_NAME(125),
    (PTR)&INTERRUPT_HANDLER_NAME(126),
    (PTR)&INTERRUPT_HANDLER_NAME(127),
    (PTR)&INTERRUPT_HANDLER_NAME(128),
    (PTR)&INTERRUPT_HANDLER_NAME(129),
    (PTR)&INTERRUPT_HANDLER_NAME(130),
    (PTR)&INTERRUPT_HANDLER_NAME(131),
    (PTR)&INTERRUPT_HANDLER_NAME(132),
    (PTR)&INTERRUPT_HANDLER_NAME(133),
    (PTR)&INTERRUPT_HANDLER_NAME(134),
    (PTR)&INTERRUPT_HANDLER_NAME(135),
    (PTR)&INTERRUPT_HANDLER_NAME(136),
    (PTR)&INTERRUPT_HANDLER_NAME(137),
    (PTR)&INTERRUPT_HANDLER_NAME(138),
    (PTR)&INTERRUPT_HANDLER_NAME(139),
    (PTR)&INTERRUPT_HANDLER_NAME(140),
    (PTR)&INTERRUPT_HANDLER_NAME(141),
    (PTR)&INTERRUPT_HANDLER_NAME(142),
    (PTR)&INTERRUPT_HANDLER_NAME(143),
    (PTR)&INTERRUPT_HANDLER_NAME(144),
    (PTR)&INTERRUPT_HANDLER_NAME(145),
    (PTR)&INTERRUPT_HANDLER_NAME(146),
    (PTR)&INTERRUPT_HANDLER_NAME(147),
    (PTR)&INTERRUPT_HANDLER_NAME(148),
    (PTR)&INTERRUPT_HANDLER_NAME(149),
    (PTR)&INTERRUPT_HANDLER_NAME(150),
    (PTR)&INTERRUPT_HANDLER_NAME(151),
    (PTR)&INTERRUPT_HANDLER_NAME(152),
    (PTR)&INTERRUPT_HANDLER_NAME(153),
    (PTR)&INTERRUPT_HANDLER_NAME(154),
    (PTR)&INTERRUPT_HANDLER_NAME(155),
    (PTR)&INTERRUPT_HANDLER_NAME(156),
    (PTR)&INTERRUPT_HANDLER_NAME(157),
    (PTR)&INTERRUPT_HANDLER_NAME(158),
    (PTR)&INTERRUPT_HANDLER_NAME(159),
    (PTR)&INTERRUPT_HANDLER_NAME(160),
    (PTR)&INTERRUPT_HANDLER_NAME(161),
    (PTR)&INTERRUPT_HANDLER_NAME(162),
    (PTR)&INTERRUPT_HANDLER_NAME(163),
    (PTR)&INTERRUPT_HANDLER_NAME(164),
    (PTR)&INTERRUPT_HANDLER_NAME(165),
    (PTR)&INTERRUPT_HANDLER_NAME(166),
    (PTR)&INTERRUPT_HANDLER_NAME(167),
    (PTR)&INTERRUPT_HANDLER_NAME(168),
    (PTR)&INTERRUPT_HANDLER_NAME(169),
    (PTR)&INTERRUPT_HANDLER_NAME(170),
    (PTR)&INTERRUPT_HANDLER_NAME(171),
    (PTR)&INTERRUPT_HANDLER_NAME(172),
    (PTR)&INTERRUPT_HANDLER_NAME(173),
    (PTR)&INTERRUPT_HANDLER_NAME(174),
    (PTR)&INTERRUPT_HANDLER_NAME(175),
    (PTR)&INTERRUPT_HANDLER_NAME(176),
    (PTR)&INTERRUPT_HANDLER_NAME(177),
    (PTR)&INTERRUPT_HANDLER_NAME(178),
    (PTR)&INTERRUPT_HANDLER_NAME(179),
    (PTR)&INTERRUPT_HANDLER_NAME(180),
    (PTR)&INTERRUPT_HANDLER_NAME(181),
    (PTR)&INTERRUPT_HANDLER_NAME(182),
    (PTR)&INTERRUPT_HANDLER_NAME(183),
    (PTR)&INTERRUPT_HANDLER_NAME(184),
    (PTR)&INTERRUPT_HANDLER_NAME(185),
    (PTR)&INTERRUPT_HANDLER_NAME(186),
    (PTR)&INTERRUPT_HANDLER_NAME(187),
    (PTR)&INTERRUPT_HANDLER_NAME(188),
    (PTR)&INTERRUPT_HANDLER_NAME(189),
    (PTR)&INTERRUPT_HANDLER_NAME(190),
    (PTR)&INTERRUPT_HANDLER_NAME(191),
    (PTR)&INTERRUPT_HANDLER_NAME(192),
    (PTR)&INTERRUPT_HANDLER_NAME(193),
    (PTR)&INTERRUPT_HANDLER_NAME(194),
    (PTR)&INTERRUPT_HANDLER_NAME(195),
    (PTR)&INTERRUPT_HANDLER_NAME(196),
    (PTR)&INTERRUPT_HANDLER_NAME(197),
    (PTR)&INTERRUPT_HANDLER_NAME(198),
    (PTR)&INTERRUPT_HANDLER_NAME(199),
    (PTR)&INTERRUPT_HANDLER_NAME(200),
    (PTR)&INTERRUPT_HANDLER_NAME(201),
    (PTR)&INTERRUPT_HANDLER_NAME(202),
    (PTR)&INTERRUPT_HANDLER_NAME(203),
    (PTR)&INTERRUPT_HANDLER_NAME(204),
    (PTR)&INTERRUPT_HANDLER_NAME(205),
    (PTR)&INTERRUPT_HANDLER_NAME(206),
    (PTR)&INTERRUPT_HANDLER_NAME(207),
    (PTR)&INTERRUPT_HANDLER_NAME(208),
    (PTR)&INTERRUPT_HANDLER_NAME(209),
    (PTR)&INTERRUPT_HANDLER_NAME(210),
    (PTR)&INTERRUPT_HANDLER_NAME(211),
    (PTR)&INTERRUPT_HANDLER_NAME(212),
    (PTR)&INTERRUPT_HANDLER_NAME(213),
    (PTR)&INTERRUPT_HANDLER_NAME(214),
    (PTR)&INTERRUPT_HANDLER_NAME(215),
    (PTR)&INTERRUPT_HANDLER_NAME(216),
    (PTR)&INTERRUPT_HANDLER_NAME(217),
    (PTR)&INTERRUPT_HANDLER_NAME(218),
    (PTR)&INTERRUPT_HANDLER_NAME(219),
    (PTR)&INTERRUPT_HANDLER_NAME(220),
    (PTR)&INTERRUPT_HANDLER_NAME(221),
    (PTR)&INTERRUPT_HANDLER_NAME(222),
    (PTR)&INTERRUPT_HANDLER_NAME(223),
    (PTR)&INTERRUPT_HANDLER_NAME(224),
    (PTR)&INTERRUPT_HANDLER_NAME(225),
    (PTR)&INTERRUPT_HANDLER_NAME(226),
    (PTR)&INTERRUPT_HANDLER_NAME(227),
    (PTR)&INTERRUPT_HANDLER_NAME(228),
    (PTR)&INTERRUPT_HANDLER_NAME(229),
    (PTR)&INTERRUPT_HANDLER_NAME(230),
    (PTR)&INTERRUPT_HANDLER_NAME(231),
    (PTR)&INTERRUPT_HANDLER_NAME(232),
    (PTR)&INTERRUPT_HANDLER_NAME(233),
    (PTR)&INTERRUPT_HANDLER_NAME(234),
    (PTR)&INTERRUPT_HANDLER_NAME(235),
    (PTR)&INTERRUPT_HANDLER_NAME(236),
    (PTR)&INTERRUPT_HANDLER_NAME(237),
    (PTR)&INTERRUPT_HANDLER_NAME(238),
    (PTR)&INTERRUPT_HANDLER_NAME(239),
    (PTR)&INTERRUPT_HANDLER_NAME(240),
    (PTR)&INTERRUPT_HANDLER_NAME(241),
    (PTR)&INTERRUPT_HANDLER_NAME(242),
    (PTR)&INTERRUPT_HANDLER_NAME(243),
    (PTR)&INTERRUPT_HANDLER_NAME(244),
    (PTR)&INTERRUPT_HANDLER_NAME(245),
    (PTR)&INTERRUPT_HANDLER_NAME(246),
    (PTR)&INTERRUPT_HANDLER_NAME(247),
    (PTR)&INTERRUPT_HANDLER_NAME(248),
    (PTR)&INTERRUPT_HANDLER_NAME(249),
    (PTR)&INTERRUPT_HANDLER_NAME(250),
    (PTR)&INTERRUPT_HANDLER_NAME(251),
    (PTR)&INTERRUPT_HANDLER_NAME(252),
    (PTR)&INTERRUPT_HANDLER_NAME(253),
    (PTR)&INTERRUPT_HANDLER_NAME(254),
    (PTR)&INTERRUPT_HANDLER_NAME(255),
};

__attribute__((naked))
VOID
KiInterruptNop(
    VOID)
{
    /*
        6.14 EXCEPTION AND INTERRUPT HANDLING IN 64-BIT MODE

        In 64-bit mode, interrupt and exception handling is similar to what has been described for non-64-bit modes. The
        following are the exceptions:
        - All interrupt handlers pointed by the IDT are in 64-bit code (this does not apply to the SMI handler).
        - The size of interrupt-stack pushes is fixed at 64 bits; and the processor uses 8-byte, zero extended stores.
        - The stack pointer (SS:RSP) is pushed unconditionally on interrupts. In legacy modes, this push is conditional
        and based on a change in current privilege level (CPL).
        - The new SS is set to NULL if there is a change in CPL.
        - IRET behavior changes.
        - There is a new interrupt stack-switch mechanism and a new interrupt shadow stack-switch mechanism.
        - The alignment of interrupt stack frame is different.    
    */

    __asm__ __volatile__ (
        "cli\n\t"
        "hlt\n\t"
        ASM_INTERRUPT_FRAME_PUSH
        "cli\n\t"
        "hlt\n\t" // Halts the system
        ASM_INTERRUPT_FRAME_POP
        "iretq\n\t"
        :
        :
        : "memory"
    );
}



INTERRUPT_HANDLER(32)
INTERRUPT_HANDLER(33)
INTERRUPT_HANDLER(34)
INTERRUPT_HANDLER(35)
INTERRUPT_HANDLER(36)
INTERRUPT_HANDLER(37)
INTERRUPT_HANDLER(38)
INTERRUPT_HANDLER(39)
INTERRUPT_HANDLER(40)
INTERRUPT_HANDLER(41)
INTERRUPT_HANDLER(42)
INTERRUPT_HANDLER(43)
INTERRUPT_HANDLER(44)
INTERRUPT_HANDLER(45)
INTERRUPT_HANDLER(46)
INTERRUPT_HANDLER(47)
INTERRUPT_HANDLER(48)
INTERRUPT_HANDLER(49)
INTERRUPT_HANDLER(50)
INTERRUPT_HANDLER(51)
INTERRUPT_HANDLER(52)
INTERRUPT_HANDLER(53)
INTERRUPT_HANDLER(54)
INTERRUPT_HANDLER(55)
INTERRUPT_HANDLER(56)
INTERRUPT_HANDLER(57)
INTERRUPT_HANDLER(58)
INTERRUPT_HANDLER(59)
INTERRUPT_HANDLER(60)
INTERRUPT_HANDLER(61)
INTERRUPT_HANDLER(62)
INTERRUPT_HANDLER(63)
INTERRUPT_HANDLER(64)
INTERRUPT_HANDLER(65)
INTERRUPT_HANDLER(66)
INTERRUPT_HANDLER(67)
INTERRUPT_HANDLER(68)
INTERRUPT_HANDLER(69)
INTERRUPT_HANDLER(70)
INTERRUPT_HANDLER(71)
INTERRUPT_HANDLER(72)
INTERRUPT_HANDLER(73)
INTERRUPT_HANDLER(74)
INTERRUPT_HANDLER(75)
INTERRUPT_HANDLER(76)
INTERRUPT_HANDLER(77)
INTERRUPT_HANDLER(78)
INTERRUPT_HANDLER(79)
INTERRUPT_HANDLER(80)
INTERRUPT_HANDLER(81)
INTERRUPT_HANDLER(82)
INTERRUPT_HANDLER(83)
INTERRUPT_HANDLER(84)
INTERRUPT_HANDLER(85)
INTERRUPT_HANDLER(86)
INTERRUPT_HANDLER(87)
INTERRUPT_HANDLER(88)
INTERRUPT_HANDLER(89)
INTERRUPT_HANDLER(90)
INTERRUPT_HANDLER(91)
INTERRUPT_HANDLER(92)
INTERRUPT_HANDLER(93)
INTERRUPT_HANDLER(94)
INTERRUPT_HANDLER(95)
INTERRUPT_HANDLER(96)
INTERRUPT_HANDLER(97)
INTERRUPT_HANDLER(98)
INTERRUPT_HANDLER(99)
INTERRUPT_HANDLER(100)
INTERRUPT_HANDLER(101)
INTERRUPT_HANDLER(102)
INTERRUPT_HANDLER(103)
INTERRUPT_HANDLER(104)
INTERRUPT_HANDLER(105)
INTERRUPT_HANDLER(106)
INTERRUPT_HANDLER(107)
INTERRUPT_HANDLER(108)
INTERRUPT_HANDLER(109)
INTERRUPT_HANDLER(110)
INTERRUPT_HANDLER(111)
INTERRUPT_HANDLER(112)
INTERRUPT_HANDLER(113)
INTERRUPT_HANDLER(114)
INTERRUPT_HANDLER(115)
INTERRUPT_HANDLER(116)
INTERRUPT_HANDLER(117)
INTERRUPT_HANDLER(118)
INTERRUPT_HANDLER(119)
INTERRUPT_HANDLER(120)
INTERRUPT_HANDLER(121)
INTERRUPT_HANDLER(122)
INTERRUPT_HANDLER(123)
INTERRUPT_HANDLER(124)
INTERRUPT_HANDLER(125)
INTERRUPT_HANDLER(126)
INTERRUPT_HANDLER(127)
INTERRUPT_HANDLER(128)
INTERRUPT_HANDLER(129)
INTERRUPT_HANDLER(130)
INTERRUPT_HANDLER(131)
INTERRUPT_HANDLER(132)
INTERRUPT_HANDLER(133)
INTERRUPT_HANDLER(134)
INTERRUPT_HANDLER(135)
INTERRUPT_HANDLER(136)
INTERRUPT_HANDLER(137)
INTERRUPT_HANDLER(138)
INTERRUPT_HANDLER(139)
INTERRUPT_HANDLER(140)
INTERRUPT_HANDLER(141)
INTERRUPT_HANDLER(142)
INTERRUPT_HANDLER(143)
INTERRUPT_HANDLER(144)
INTERRUPT_HANDLER(145)
INTERRUPT_HANDLER(146)
INTERRUPT_HANDLER(147)
INTERRUPT_HANDLER(148)
INTERRUPT_HANDLER(149)
INTERRUPT_HANDLER(150)
INTERRUPT_HANDLER(151)
INTERRUPT_HANDLER(152)
INTERRUPT_HANDLER(153)
INTERRUPT_HANDLER(154)
INTERRUPT_HANDLER(155)
INTERRUPT_HANDLER(156)
INTERRUPT_HANDLER(157)
INTERRUPT_HANDLER(158)
INTERRUPT_HANDLER(159)
INTERRUPT_HANDLER(160)
INTERRUPT_HANDLER(161)
INTERRUPT_HANDLER(162)
INTERRUPT_HANDLER(163)
INTERRUPT_HANDLER(164)
INTERRUPT_HANDLER(165)
INTERRUPT_HANDLER(166)
INTERRUPT_HANDLER(167)
INTERRUPT_HANDLER(168)
INTERRUPT_HANDLER(169)
INTERRUPT_HANDLER(170)
INTERRUPT_HANDLER(171)
INTERRUPT_HANDLER(172)
INTERRUPT_HANDLER(173)
INTERRUPT_HANDLER(174)
INTERRUPT_HANDLER(175)
INTERRUPT_HANDLER(176)
INTERRUPT_HANDLER(177)
INTERRUPT_HANDLER(178)
INTERRUPT_HANDLER(179)
INTERRUPT_HANDLER(180)
INTERRUPT_HANDLER(181)
INTERRUPT_HANDLER(182)
INTERRUPT_HANDLER(183)
INTERRUPT_HANDLER(184)
INTERRUPT_HANDLER(185)
INTERRUPT_HANDLER(186)
INTERRUPT_HANDLER(187)
INTERRUPT_HANDLER(188)
INTERRUPT_HANDLER(189)
INTERRUPT_HANDLER(190)
INTERRUPT_HANDLER(191)
INTERRUPT_HANDLER(192)
INTERRUPT_HANDLER(193)
INTERRUPT_HANDLER(194)
INTERRUPT_HANDLER(195)
INTERRUPT_HANDLER(196)
INTERRUPT_HANDLER(197)
INTERRUPT_HANDLER(198)
INTERRUPT_HANDLER(199)
INTERRUPT_HANDLER(200)
INTERRUPT_HANDLER(201)
INTERRUPT_HANDLER(202)
INTERRUPT_HANDLER(203)
INTERRUPT_HANDLER(204)
INTERRUPT_HANDLER(205)
INTERRUPT_HANDLER(206)
INTERRUPT_HANDLER(207)
INTERRUPT_HANDLER(208)
INTERRUPT_HANDLER(209)
INTERRUPT_HANDLER(210)
INTERRUPT_HANDLER(211)
INTERRUPT_HANDLER(212)
INTERRUPT_HANDLER(213)
INTERRUPT_HANDLER(214)
INTERRUPT_HANDLER(215)
INTERRUPT_HANDLER(216)
INTERRUPT_HANDLER(217)
INTERRUPT_HANDLER(218)
INTERRUPT_HANDLER(219)
INTERRUPT_HANDLER(220)
INTERRUPT_HANDLER(221)
INTERRUPT_HANDLER(222)
INTERRUPT_HANDLER(223)
INTERRUPT_HANDLER(224)
INTERRUPT_HANDLER(225)
INTERRUPT_HANDLER(226)
INTERRUPT_HANDLER(227)
INTERRUPT_HANDLER(228)
INTERRUPT_HANDLER(229)
INTERRUPT_HANDLER(230)
INTERRUPT_HANDLER(231)
INTERRUPT_HANDLER(232)
INTERRUPT_HANDLER(233)
INTERRUPT_HANDLER(234)
INTERRUPT_HANDLER(235)
INTERRUPT_HANDLER(236)
INTERRUPT_HANDLER(237)
INTERRUPT_HANDLER(238)
INTERRUPT_HANDLER(239)
INTERRUPT_HANDLER(240)
INTERRUPT_HANDLER(241)
INTERRUPT_HANDLER(242)
INTERRUPT_HANDLER(243)
INTERRUPT_HANDLER(244)
INTERRUPT_HANDLER(245)
INTERRUPT_HANDLER(246)
INTERRUPT_HANDLER(247)
INTERRUPT_HANDLER(248)
INTERRUPT_HANDLER(249)
INTERRUPT_HANDLER(250)
INTERRUPT_HANDLER(251)
INTERRUPT_HANDLER(252)
INTERRUPT_HANDLER(253)
INTERRUPT_HANDLER(254)
INTERRUPT_HANDLER(255)



BOOLEAN
KERNELAPI
KiSetInterruptVector(
    IN ARCH_X64_IDTENTRY *Idt,
    IN U16 Vector,
    IN U64 BaseOffset,
    IN U16 Selector,
    IN U16 Attributes)
{
    UPTR Offset64 = (UPTR)BaseOffset;

    if (Vector >= 0x100)
        return FALSE;

    Idt[Vector] = (ARCH_X64_IDTENTRY) {
        .Reserved = 0, 
        .Selector = Selector, 
        .OffsetLow = (U16)((Offset64 & 0x000000000000ffffULL) >> 0x00),
        .OffsetMid = (U16)((Offset64 & 0x00000000ffff0000ULL) >> 0x10),
        .OffsetHigh = (U32)((Offset64 & 0xffffffff00000000ULL) >> 0x20),
        .Attributes = Attributes, 
    };

    return TRUE;
}

VOID
KERNELAPI
KiSetSegmentDescriptor(
    IN U64 *Gdt,
    IN U16 Selector,
    IN U64 Descriptor)
{
    Gdt[SELECTOR_TO_INDEX(Selector)] = Descriptor;
}

VOID
KERNELAPI
KiInitializeGdtIdt(
    IN U64 *Gdt,
    IN ARCH_X64_IDTENTRY *Idt)
{
    U64 DefaultDescriptor64 = 
        ARCH_X64_SEGMENT_PRESENT | ARCH_X64_SEGMENT_CODE_DATA | ARCH_X64_SEGMENT_GRANULARITY;
    U64 DefaultCodeDescriptor64 = DefaultDescriptor64 | ARCH_X64_SEGMENT_64BIT | 
        ARCH_X64_SEGMENT_TYPE(ARCH_X64_SEGMENT_TYPE_CODE_EXECUTE_READ);
    U64 DefaultDataDescriptor64 = DefaultDescriptor64 | ARCH_X64_SEGMENT_DEFAULT | 
        ARCH_X64_SEGMENT_TYPE(ARCH_X64_SEGMENT_TYPE_DATA_READWRITE);

    for (U16 i = 0; i < GDTENTRY_MAXIMUM_COUNT; i++)
    {
        Gdt[i] = 0;
    }

    KiSetSegmentDescriptor(Gdt, NULL_XS, 0);
    KiSetSegmentDescriptor(Gdt, KERNEL_CS32, 0); // currently not used
    KiSetSegmentDescriptor(Gdt, KERNEL_DS32, 0); // currently not used

    KiSetSegmentDescriptor(Gdt, KERNEL_CS, DefaultCodeDescriptor64 | ARCH_X64_SEGMENT_DPL(0));
    KiSetSegmentDescriptor(Gdt, KERNEL_DS, DefaultDataDescriptor64 | ARCH_X64_SEGMENT_DPL(0));
    KiSetSegmentDescriptor(Gdt, KERNEL_FS, DefaultDataDescriptor64 | ARCH_X64_SEGMENT_DPL(0));
    KiSetSegmentDescriptor(Gdt, KERNEL_GS, DefaultDataDescriptor64 | ARCH_X64_SEGMENT_DPL(0));

    KiSetSegmentDescriptor(Gdt, USER_CS, DefaultCodeDescriptor64 | ARCH_X64_SEGMENT_DPL(3));
    KiSetSegmentDescriptor(Gdt, USER_DS, DefaultDataDescriptor64 | ARCH_X64_SEGMENT_DPL(3));
    KiSetSegmentDescriptor(Gdt, USER_FS, DefaultDataDescriptor64 | ARCH_X64_SEGMENT_DPL(3));
    KiSetSegmentDescriptor(Gdt, USER_GS, DefaultDataDescriptor64 | ARCH_X64_SEGMENT_DPL(3));

    for (U16 Vector = 0; Vector < IDTENTRY_MAXIMUM_COUNT; Vector++)
    {
        if (!KiSetInterruptVector(Idt, Vector, (U64)KiInterruptHandlers[Vector], KERNEL_CS, 
            ARCH_X64_IDTENTRY_ATTRIBUTE_PRESENT |
            ARCH_X64_IDTENTRY_ATTRIBUTE_TYPE(ARCH_X64_IDTENTRY_ATTRIBUTE_TYPE_INTERRUPT) | 
            ARCH_X64_IDTENTRY_ATTRIBUTE_DPL(0) |
            ARCH_X64_IDTENTRY_ATTRIBUTE_IST(0)))
        {
            FATAL("Failed to set interrupt vector 0x%04hx. (bogus vector number?)", Vector);
        }
    }
}

VOID
KiLoadGdtIdt(
    IN U64 *Gdt,
    IN U16 GdtLimit,
    IN ARCH_X64_IDTENTRY *Idt,
    IN U16 IdtLimit)
{
    ARCH_X64_XDTR Gdtr = { .Base = (U64)Gdt, .Limit = GdtLimit, };
    ARCH_X64_XDTR Idtr = { .Base = (U64)Idt, .Limit = IdtLimit, };

    __lgdt(&Gdtr);
    __lidt(&Idtr);

/*
    __asm__ __volatile__ (
        "lgdt [%0]\n\t"
        "lidt [%1]\n\t"
        :
        : "r"(&Gdtr), "r"(&Idtr)
        : "memory"
    );
*/
}

__attribute__((naked, noinline))
VOID
KiReloadSegments(
    VOID)
{
/*
    __asm__ __volatile__ (
        "mov ds, %0\n\t"
        "mov es, %1\n\t"
        "mov fs, %2\n\t"
        "mov gs, %3\n\t"
        "mov ss, %4\n\t"
        "pop rax\n\t"
        "push %5\n\t"
        "push rax\n\t"
        "retf\n\t"
        :
        : "a"(KERNEL_DS), "a"(KERNEL_DS), "a"(KERNEL_FS), 
          "a"(KERNEL_GS), "a"(KERNEL_SS), "i"(KERNEL_CS)
        : "memory"
    );
*/
    __asm__ __volatile__ (
        "mov eax, %0\n\t"
        "mov ds, ax\n\t"
        "mov es, ax\n\t"
        "mov eax, %1\n\t"
        "mov fs, ax\n\t"
        "mov eax, %2\n\t"
        "mov gs, ax\n\t"
        "mov eax, %3\n\t"
        "mov ss, ax\n\t"
        "pop rax\n\t"
        "push %4\n\t"
        "push rax\n\t"

        //
        // NOTE: default operation size of retf is 32-bit even in the long mode.
        //       use lretq (or rex.W retf) instead.
        //

        "lretq\n\t" // same as rex.W retf
        :
        : "i"(KERNEL_DS), "i"(KERNEL_FS), "i"(KERNEL_GS), "i"(KERNEL_SS), 
          "i"(KERNEL_CS)
        : "rax", "memory"
    );
}

VOID
KERNELAPI
KiInitializeProcessor(
    VOID)
{
    KPROCESSOR *Processor = MmAllocatePool(PoolTypeNonPaged, sizeof(*Processor), 0x10, 0);
    if (!Processor)
    {
        FATAL("Failed to allocate processor structure");
    }

    //
    // Initialize GDT and IDT.
    //

    ARCH_X64_IDTENTRY *Idt = MmAllocatePool(PoolTypeNonPaged, IDT_LIMIT + 1, 0x10, 0);
    if (!Idt)
    {
        FATAL("Failed to allocate IDT");
    }

    U64 *Gdt = MmAllocatePool(PoolTypeNonPaged, GDT_LIMIT + 1, 0x10, 0);
    if (!Gdt)
    {
        FATAL("Failed to allocate GDT");
    }

    KiInitializeGdtIdt(Gdt, Idt);

    //
    // Initialize TSS with 7 interrupt stacks.
    //

    ARCH_X64_TSS *Tss = MmAllocatePool(PoolTypeNonPaged, sizeof(ARCH_X64_TSS), 0x10, 0);
    SIZE_T TssLimit = sizeof(*Tss) - 1;
    if (!Tss)
    {
        FATAL("Failed to allocate TSS");
    }

    PTR Ist[7] = { 0 }, Rsp0 = 0;
    SIZE_T StackSize = 0x20000;
    Rsp0 = (PTR)MmAllocatePool(PoolTypeNonPaged, StackSize, 0x10, 0);
    if (!Rsp0)
    {
        FATAL("Failed to initialize TSS (RSP0)");
    }

    for (INT i = 0; i < COUNTOF(Ist); i++)
    {
        Ist[i] = (PTR)MmAllocatePool(PoolTypeNonPaged, StackSize, 0x10, 0);
        if (!Ist[i])
        {
            FATAL("Failed to initialize TSS (IST)");
        }
    }

    memset(Tss, 0, sizeof(*Tss));
    Tss->Rsp0 = Rsp0 + StackSize - sizeof(U64) * 2;
    Tss->Ist1 = Ist[0] + StackSize - sizeof(U64) * 2;
    Tss->Ist2 = Ist[1] + StackSize - sizeof(U64) * 2;
    Tss->Ist3 = Ist[2] + StackSize - sizeof(U64) * 2;
    Tss->Ist4 = Ist[3] + StackSize - sizeof(U64) * 2;
    Tss->Ist5 = Ist[4] + StackSize - sizeof(U64) * 2;
    Tss->Ist6 = Ist[5] + StackSize - sizeof(U64) * 2;
    Tss->Ist7 = Ist[6] + StackSize - sizeof(U64) * 2;
    Tss->IoMapBase = sizeof(Tss); // disable I/O permission

    // 
    // Setup TSS to the GDT.
    // Note that TSS(or LDT) descriptor takes 16-byte.
    // 

    // TSS selector.
    KiSetSegmentDescriptor(Gdt, KERNEL_TSS, 
        ARCH_X64_SEGMENT_PRESENT | ARCH_X64_SEGMENT_TYPE(ARCH_X64_SEGMENT_TYPE_SYSTEM_TSS) | ARCH_X64_SEGMENT_DPL(0) | 
        (((U64)Tss & 0xffffff) << 0x10) | (((U64)Tss & 0xff0000) << 0x20) | 
        ((U64)TssLimit & 0xffff) | (((U64)TssLimit & 0xf0000) << 0x20));

    // Higher 32-bit offset.
    KiSetSegmentDescriptor(Gdt, KERNEL_HIGH_TSS, (((U64)Tss >> 0x20) & 0xffffffff));


    //
    // Load GDTR, IDTR, and TR.
    //

    // 
    // The operating system must create at least one 64-bit TSS after activating IA-32e mode. 
    // It must execute the LTR instruction (in 64-bit mode) to load the TR register with a pointer
    // to the 64-bit TSS responsible for both 64-bit mode programs and compatibility-mode programs.
    //
    // [From: Intel SDM. 7.7 TASK MANAGEMENT IN 64-BIT MODE]
    // 

    KiLoadGdtIdt(Gdt, GDT_LIMIT, Idt, IDT_LIMIT);
    __ltr(KERNEL_TSS);


    //
    // Load new segment registers.
    //

    KiReloadSegments();

    Processor->Self = Processor;
    Processor->Idt = Idt;
    Processor->Gdt = Gdt;
    Processor->Tss = Tss;
    Processor->ProcessorId = -1;
}

VOID
KERNELAPI
KiInitialize(
    VOID)
{
    KiInitializeProcessor();

    //
    // Initialize IRQ groups.
    //

    for (KIRQL Irql = IRQL_LOWEST; Irql <= IRQL_HIGHEST; Irql++)
    {
        KIRQ_GROUP *IrqGroup = &KiIrqGroup[Irql];

        KeInitializeSpinlock(&IrqGroup->GroupLock);
        IrqGroup->PreviousIrql = IRQL_LOWEST;
        IrqGroup->GroupIrql = IRQL_LOWEST;

        for (ULONG i = 0; i < IRQS_PER_IRQ_GROUP; i++)
        {
            KIRQ *Irq = &IrqGroup->Irq[i];
            Irq->Allocated = FALSE;
            Irq->Shared = FALSE;
            Irq->SharedCount = 0;
            DListInitializeHead(&Irq->InterruptListHead);
        }
    }

}

